// SPDX-FileCopyrightText: 2026 The Keepers of the CryptoHives
// SPDX-License-Identifier: MIT

namespace CryptoHives.Foundation.Security.Cryptography.Hash;

using System;
using System.Buffers.Binary;
using System.Runtime.CompilerServices;

/// <summary>
/// Computes the Kupyna (DSTU 7564:2014) hash for the input data.
/// </summary>
/// <remarks>
/// <para>
/// <strong>WARNING: This implementation is a work-in-progress and does not produce correct output.</strong>
/// Use BouncyCastle's <c>Dstu7564Digest</c> for production use until this is fixed.
/// </para>
/// <para>
/// This is a fully managed implementation of Kupyna that does not rely on
/// OS or hardware cryptographic APIs, ensuring deterministic behavior across
/// all platforms and runtimes.
/// </para>
/// <para>
/// Kupyna is the Ukrainian national cryptographic hash standard defined in DSTU 7564:2014.
/// It supports output sizes of 256, 384, or 512 bits.
/// </para>
/// <para>
/// The algorithm uses a Davies-Meyer compression function with permutations derived from
/// the Kalyna block cipher (DSTU 7624:2014). It is structurally similar to Grøstl.
/// </para>
/// </remarks>
/// TODO: Debug and fix the implementation - round constants, shift patterns, or MDS matrix may be incorrect.
public sealed class Kupyna : HashAlgorithm
{
    /// <summary>
    /// Block size in bytes for 256-bit hash (512-bit state).
    /// </summary>
    private const int BlockSize256 = 64;

    /// <summary>
    /// Block size in bytes for 384/512-bit hash (1024-bit state).
    /// </summary>
    private const int BlockSize512 = 128;

    /// <summary>
    /// Number of rows in the state matrix.
    /// </summary>
    private const int Rows = 8;

    // S-boxes from DSTU 7564:2014
    private static readonly byte[] S0 =
    [
        0xa8, 0x43, 0x5f, 0x06, 0x6b, 0x75, 0x6c, 0x59, 0x71, 0xdf, 0x87, 0x95, 0x17, 0xf0, 0xd8, 0x09,
        0x6d, 0xf3, 0x1d, 0xcb, 0xc9, 0x4d, 0x2c, 0xaf, 0x79, 0xe0, 0x97, 0xfd, 0x6f, 0x4b, 0x45, 0x39,
        0x3e, 0xdd, 0xa3, 0x4f, 0xb4, 0xb6, 0x9a, 0x0e, 0x1f, 0xbf, 0x15, 0xe1, 0x49, 0xd2, 0x93, 0xc6,
        0x92, 0x72, 0x9e, 0x61, 0xd1, 0x63, 0xfa, 0xee, 0xf4, 0x19, 0xd5, 0xad, 0x58, 0xa4, 0xbb, 0xa1,
        0xdc, 0xf2, 0x83, 0x37, 0x42, 0xe4, 0x7a, 0x32, 0x9c, 0xcc, 0xab, 0x4a, 0x8f, 0x6e, 0x04, 0x27,
        0x2e, 0xe7, 0xe2, 0x5a, 0x96, 0x16, 0x23, 0x2b, 0xc2, 0x65, 0x66, 0x0f, 0xbc, 0xa9, 0x47, 0x41,
        0x34, 0x48, 0xfc, 0xb7, 0x6a, 0x88, 0xa5, 0x53, 0x86, 0xf9, 0x5b, 0xdb, 0x38, 0x7b, 0xc3, 0x1e,
        0x22, 0x33, 0x24, 0x28, 0x36, 0xc7, 0xb2, 0x3b, 0x8e, 0x77, 0xba, 0xf5, 0x14, 0x9f, 0x08, 0x55,
        0x9b, 0x4c, 0xfe, 0x60, 0x5c, 0xda, 0x18, 0x46, 0xcd, 0x7d, 0x21, 0xb0, 0x3f, 0x1b, 0x89, 0xff,
        0xeb, 0x84, 0x69, 0x3a, 0x9d, 0xd7, 0xd3, 0x70, 0x67, 0x40, 0xb5, 0xde, 0x5d, 0x30, 0x91, 0xb1,
        0x78, 0x11, 0x01, 0xe5, 0x00, 0x68, 0x98, 0xa0, 0xc5, 0x02, 0xa6, 0x74, 0x2d, 0x0b, 0xa2, 0x76,
        0xb3, 0xbe, 0xce, 0xbd, 0xae, 0xe9, 0x8a, 0x31, 0x1c, 0xec, 0xf1, 0x99, 0x94, 0xaa, 0xf6, 0x26,
        0x2f, 0xef, 0xe8, 0x8c, 0x35, 0x03, 0xd4, 0x7f, 0xfb, 0x05, 0xc1, 0x5e, 0x90, 0x20, 0x3d, 0x82,
        0xf7, 0xea, 0x0a, 0x0d, 0x7e, 0xf8, 0x50, 0x1a, 0xc4, 0x07, 0x57, 0xb8, 0x3c, 0x62, 0xe3, 0xc8,
        0xac, 0x52, 0x64, 0x10, 0xd0, 0xd9, 0x13, 0x0c, 0x12, 0x29, 0x51, 0xb9, 0xcf, 0xd6, 0x73, 0x8d,
        0x81, 0x54, 0xc0, 0xed, 0x4e, 0x44, 0xa7, 0x2a, 0x85, 0x25, 0xe6, 0xca, 0x7c, 0x8b, 0x56, 0x80
    ];

    private static readonly byte[] S1 =
    [
        0xce, 0xbb, 0xeb, 0x92, 0xea, 0xcb, 0x13, 0xc1, 0xe9, 0x3a, 0xd6, 0xb2, 0xd2, 0x90, 0x17, 0xf8,
        0x42, 0x15, 0x56, 0xb4, 0x65, 0x1c, 0x88, 0x43, 0xc5, 0x5c, 0x36, 0xba, 0xf5, 0x57, 0x67, 0x8d,
        0x31, 0xf6, 0x64, 0x58, 0x9e, 0xf4, 0x22, 0xaa, 0x75, 0x0f, 0x02, 0xb1, 0xdf, 0x6d, 0x73, 0x4d,
        0x7c, 0x26, 0x2e, 0xf7, 0x08, 0x5d, 0x44, 0x3e, 0x9f, 0x14, 0xc8, 0xae, 0x54, 0x10, 0xd8, 0xbc,
        0x1a, 0x6b, 0x69, 0xf3, 0xbd, 0x33, 0xab, 0xfa, 0xd1, 0x9b, 0x68, 0x4e, 0x16, 0x95, 0x91, 0xee,
        0x4c, 0x63, 0x8e, 0x5b, 0xcc, 0x3c, 0x19, 0xa1, 0x81, 0x49, 0x7b, 0xd9, 0x6f, 0x37, 0x60, 0xca,
        0xe7, 0x2b, 0x48, 0xfd, 0x96, 0x45, 0xfc, 0x41, 0x12, 0x0d, 0x79, 0xe5, 0x89, 0x8c, 0xe3, 0x20,
        0x30, 0xdc, 0xb7, 0x6c, 0x4a, 0xb5, 0x3f, 0x97, 0xd4, 0x62, 0x2d, 0x06, 0xa4, 0xa5, 0x83, 0x5f,
        0x2a, 0xda, 0xc9, 0x00, 0x7e, 0xa2, 0x55, 0xbf, 0x11, 0xd5, 0x9c, 0xcf, 0x0e, 0x0a, 0x3d, 0x51,
        0x7d, 0x93, 0x1b, 0xfe, 0xc4, 0x47, 0x09, 0x86, 0x0b, 0x8f, 0x9d, 0x6a, 0x07, 0xb9, 0xb0, 0x98,
        0x18, 0x32, 0x71, 0x29, 0xc3, 0x3b, 0xf0, 0xe1, 0xa3, 0x78, 0xf1, 0x35, 0x1f, 0xb3, 0x1d, 0xac,
        0xe0, 0x23, 0xf2, 0xa6, 0x4b, 0xd0, 0x2c, 0xa8, 0x87, 0xe2, 0x76, 0x66, 0x7f, 0x39, 0x99, 0xcd,
        0x04, 0x82, 0xd3, 0x28, 0x84, 0x38, 0xc0, 0xa7, 0xa9, 0x53, 0x52, 0x8a, 0xec, 0x72, 0x50, 0x05,
        0x1e, 0xff, 0x85, 0x24, 0x70, 0xe4, 0xed, 0xb8, 0x77, 0x80, 0xe8, 0xad, 0x01, 0xef, 0x59, 0xb6,
        0xc6, 0xe6, 0x9a, 0x03, 0xfb, 0x6e, 0x27, 0xc2, 0x5e, 0x8b, 0x0c, 0x25, 0xde, 0x94, 0x74, 0xdb,
        0x40, 0xc7, 0x2f, 0x5a, 0x34, 0x46, 0x7a, 0x4f, 0xdd, 0xa0, 0xaf, 0x61, 0xd7, 0xbe, 0xcc, 0x3a
    ];

    private static readonly byte[] S2 =
    [
        0x1e, 0x6d, 0x5a, 0x85, 0x72, 0x8c, 0x61, 0xf6, 0xbe, 0xeb, 0x84, 0xd0, 0x63, 0xf4, 0x24, 0xab,
        0x3a, 0x06, 0xed, 0x45, 0xb5, 0x92, 0x33, 0x90, 0xd8, 0xbc, 0x49, 0xbb, 0xea, 0x79, 0x6e, 0x9a,
        0x01, 0x02, 0xf1, 0xb8, 0x36, 0xef, 0xa3, 0x51, 0x31, 0xe9, 0x1f, 0x78, 0x76, 0x4c, 0x4a, 0xf9,
        0x1d, 0xe3, 0x93, 0x67, 0x44, 0x25, 0xae, 0xbf, 0x54, 0x57, 0xd1, 0xa2, 0xa4, 0x2c, 0xd4, 0xdf,
        0x95, 0xc6, 0x2f, 0xd5, 0x00, 0x05, 0x70, 0x29, 0x9e, 0x55, 0xba, 0x0b, 0x74, 0xc2, 0x40, 0x18,
        0x0c, 0x8a, 0x5f, 0x80, 0xf8, 0x3b, 0x68, 0xcd, 0x20, 0xad, 0xcf, 0x9c, 0x4b, 0x0a, 0x52, 0xe4,
        0x8e, 0xd9, 0x38, 0xa9, 0xd7, 0x53, 0x3f, 0x22, 0x37, 0x46, 0x94, 0x73, 0xa0, 0x2b, 0x27, 0xcc,
        0x3c, 0x4e, 0x30, 0x1b, 0x11, 0x65, 0xf0, 0x87, 0xc0, 0xec, 0xe2, 0x13, 0xe8, 0xc1, 0x5d, 0x58,
        0xe0, 0x07, 0xb4, 0x10, 0x50, 0x09, 0x19, 0xfa, 0x0e, 0x08, 0xfb, 0x41, 0xc8, 0x16, 0xa1, 0x0f,
        0x6a, 0x9b, 0x99, 0xca, 0x81, 0xb0, 0x4f, 0x14, 0x23, 0x5b, 0xce, 0x7b, 0x62, 0xee, 0x12, 0xdc,
        0x75, 0x04, 0xfe, 0x42, 0x64, 0x98, 0xb1, 0xf3, 0xdd, 0xdb, 0xb2, 0xa7, 0xda, 0xb6, 0xfc, 0x88,
        0xe7, 0x5e, 0x69, 0x56, 0x77, 0x2e, 0xac, 0x48, 0x28, 0x8b, 0x9d, 0x60, 0x03, 0xc5, 0xe1, 0x8d,
        0x71, 0xbd, 0x89, 0xd2, 0x7c, 0xaf, 0xc3, 0x7e, 0x86, 0xff, 0x6f, 0xf2, 0xb9, 0xe5, 0xc7, 0x2a,
        0xc4, 0x96, 0x59, 0x82, 0x7a, 0xcb, 0xf7, 0xaa, 0x7f, 0x6c, 0x47, 0x83, 0x0d, 0x91, 0x35, 0xfd,
        0x43, 0x8f, 0x39, 0xa6, 0xd3, 0xd6, 0x17, 0xc9, 0xb3, 0x97, 0xde, 0x21, 0x32, 0x26, 0x34, 0x4d,
        0x5c, 0x15, 0x1c, 0xb7, 0x1a, 0xa5, 0x3d, 0x7d, 0x3e, 0x6b, 0x66, 0xe6, 0xa8, 0x9f, 0xf5, 0x2d
    ];

    private static readonly byte[] S3 =
    [
        0x6c, 0xda, 0xc3, 0x59, 0x09, 0xa0, 0x9f, 0x83, 0x5e, 0x3b, 0xf6, 0xf5, 0x10, 0x02, 0x4a, 0x01,
        0x27, 0xc2, 0xcc, 0xfc, 0x9b, 0x6b, 0xba, 0x06, 0x75, 0x91, 0xab, 0xce, 0xe7, 0x64, 0x8e, 0x66,
        0x3c, 0xae, 0x15, 0x5f, 0x94, 0xb6, 0x8d, 0xb5, 0x81, 0xa1, 0x87, 0x72, 0x0f, 0xbf, 0xd7, 0x8c,
        0xf9, 0xf7, 0x56, 0xed, 0x9c, 0xdd, 0xfe, 0x69, 0xb7, 0x79, 0x7c, 0x0e, 0x7f, 0x98, 0xb2, 0x80,
        0xe6, 0x60, 0xd2, 0x38, 0xdf, 0x53, 0xe9, 0x2e, 0x6a, 0xac, 0x4c, 0x7a, 0xd0, 0xa4, 0x96, 0x45,
        0x8a, 0x50, 0xfb, 0x1e, 0xd5, 0xf8, 0x40, 0x4b, 0x13, 0x21, 0x0c, 0xe3, 0xf0, 0x67, 0x99, 0x1a,
        0x89, 0x35, 0xcb, 0x24, 0x73, 0xca, 0x61, 0x8b, 0x41, 0xd8, 0x85, 0x76, 0xc0, 0x54, 0x17, 0xbc,
        0x0a, 0x9e, 0x5b, 0x2d, 0xea, 0x44, 0xd4, 0x18, 0x05, 0x16, 0xb9, 0xbb, 0xa8, 0x3e, 0xf2, 0x7e,
        0x78, 0x03, 0x2a, 0xa6, 0xf3, 0xef, 0x6f, 0x30, 0x42, 0xc6, 0x49, 0xec, 0x7d, 0x68, 0x1d, 0x92,
        0xbd, 0xfa, 0x12, 0x93, 0x00, 0xc1, 0xe4, 0x57, 0x31, 0x25, 0x7b, 0x07, 0x5a, 0x4e, 0x77, 0xcd,
        0xeb, 0x37, 0x2b, 0x71, 0xb4, 0x0d, 0xc7, 0xb3, 0xdc, 0x97, 0xdb, 0xd1, 0xe5, 0x8f, 0xe2, 0x2f,
        0xe1, 0xd9, 0xd6, 0xb0, 0xaa, 0xf4, 0x84, 0x65, 0x52, 0xff, 0x1f, 0xa5, 0x20, 0x08, 0x86, 0x5d,
        0x1b, 0xc4, 0x9d, 0x70, 0x88, 0x51, 0x34, 0xcf, 0x22, 0x3f, 0x0b, 0xb8, 0x29, 0x33, 0x4f, 0x19,
        0x95, 0x1c, 0xfd, 0x63, 0xe8, 0xd3, 0x04, 0x6e, 0xa3, 0x28, 0x14, 0xee, 0x39, 0x5c, 0x90, 0x2c,
        0xa2, 0x55, 0xbe, 0xa7, 0x48, 0x11, 0xc5, 0x26, 0x62, 0x82, 0x74, 0x47, 0x4d, 0xf1, 0xa9, 0xad,
        0xde, 0xe0, 0x43, 0xc9, 0x36, 0x3a, 0x23, 0x46, 0x6d, 0xaf, 0xc8, 0x32, 0x3d, 0x58, 0x9a, 0xb1
    ];

    // MDS matrix for MixColumns (from DSTU 7564:2014)
    private static readonly byte[] MdsMatrix =
    [
        0x01, 0x01, 0x05, 0x01, 0x08, 0x06, 0x07, 0x04,
        0x04, 0x01, 0x01, 0x05, 0x01, 0x08, 0x06, 0x07,
        0x07, 0x04, 0x01, 0x01, 0x05, 0x01, 0x08, 0x06,
        0x06, 0x07, 0x04, 0x01, 0x01, 0x05, 0x01, 0x08,
        0x08, 0x06, 0x07, 0x04, 0x01, 0x01, 0x05, 0x01,
        0x01, 0x08, 0x06, 0x07, 0x04, 0x01, 0x01, 0x05,
        0x05, 0x01, 0x08, 0x06, 0x07, 0x04, 0x01, 0x01,
        0x01, 0x05, 0x01, 0x08, 0x06, 0x07, 0x04, 0x01
    ];

    private readonly int _hashSizeBytes;
    private readonly int _blockSize;
    private readonly int _columns;
    private readonly int _rounds;
    private readonly byte[] _state;
    private readonly byte[] _buffer;
    private int _bufferLength;
    private ulong _totalLength;

    /// <summary>
    /// Initializes a new instance of the <see cref="Kupyna"/> class with 512-bit output.
    /// </summary>
    public Kupyna() : this(64)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="Kupyna"/> class.
    /// </summary>
    /// <param name="hashSizeBytes">The desired output size in bytes (32, 48, or 64).</param>
    public Kupyna(int hashSizeBytes)
    {
        if (hashSizeBytes != 32 && hashSizeBytes != 48 && hashSizeBytes != 64)
            throw new ArgumentException("Hash size must be 32 (256-bit), 48 (384-bit), or 64 (512-bit) bytes.", nameof(hashSizeBytes));

        _hashSizeBytes = hashSizeBytes;
        HashSizeValue = hashSizeBytes * 8;

        // For 256-bit: 512-bit state (64 bytes), 8 columns, 10 rounds
        // For 384/512-bit: 1024-bit state (128 bytes), 16 columns, 14 rounds
        if (hashSizeBytes <= 32)
        {
            _blockSize = BlockSize256;
            _columns = 8;
            _rounds = 10;
        }
        else
        {
            _blockSize = BlockSize512;
            _columns = 16;
            _rounds = 14;
        }

        _state = new byte[_blockSize];
        _buffer = new byte[_blockSize];
        Initialize();
    }

    /// <inheritdoc/>
    public override string AlgorithmName => $"Kupyna-{_hashSizeBytes * 8}";

    /// <inheritdoc/>
    public override int BlockSize => _blockSize;

    /// <summary>
    /// Creates a new instance with default 512-bit output.
    /// </summary>
    public static new Kupyna Create() => new();

    /// <summary>
    /// Creates a new instance with specified output size.
    /// </summary>
    /// <param name="hashSizeBytes">The hash size in bytes (32, 48, or 64).</param>
    public static Kupyna Create(int hashSizeBytes) => new(hashSizeBytes);

    /// <inheritdoc/>
    public override void Initialize()
    {
        Array.Clear(_state, 0, _state.Length);
        // Set IV: state[0..7] = hash_size_in_bits (little-endian 64-bit value)
        int hashSizeBits = _hashSizeBytes * 8;
        _state[0] = unchecked((byte)hashSizeBits);
        _state[1] = unchecked((byte)(hashSizeBits >> 8));
        // Remaining bytes are already zero from Array.Clear

        ClearBuffer(_buffer);
        _bufferLength = 0;
        _totalLength = 0;
    }

    /// <inheritdoc/>
    protected override void HashCore(ReadOnlySpan<byte> source)
    {
        int offset = 0;

        // Fill buffer if partially full
        if (_bufferLength > 0)
        {
            int toCopy = Math.Min(_blockSize - _bufferLength, source.Length);
            source.Slice(0, toCopy).CopyTo(_buffer.AsSpan(_bufferLength));
            _bufferLength += toCopy;
            offset += toCopy;

            if (_bufferLength == _blockSize)
            {
                ProcessBlock(_buffer);
                _totalLength += (ulong)_blockSize;
                _bufferLength = 0;
            }
        }

        // Process full blocks
        while (offset + _blockSize <= source.Length)
        {
            ProcessBlock(source.Slice(offset, _blockSize));
            _totalLength += (ulong)_blockSize;
            offset += _blockSize;
        }

        // Buffer remainder
        int remaining = source.Length - offset;
        if (remaining > 0)
        {
            source.Slice(offset, remaining).CopyTo(_buffer.AsSpan());
            _bufferLength = remaining;
        }
    }

    /// <inheritdoc/>
    protected override bool TryHashFinal(Span<byte> destination, out int bytesWritten)
    {
        if (destination.Length < _hashSizeBytes)
        {
            bytesWritten = 0;
            return false;
        }

        unchecked
        {
            // Total message length in bits
            ulong totalBits = (_totalLength + (ulong)_bufferLength) * 8;

            // Pad with 0x80 followed by zeros
            _buffer[_bufferLength++] = 0x80;

            // Check if we need an extra block for padding
            int lengthFieldSize = _blockSize <= 64 ? 12 : 12; // 96 bits for message length
            if (_bufferLength > _blockSize - lengthFieldSize)
            {
                // Fill rest with zeros and process
                Array.Clear(_buffer, _bufferLength, _blockSize - _bufferLength);
                ProcessBlock(_buffer);
                _bufferLength = 0;
            }

            // Fill with zeros up to length field position
            Array.Clear(_buffer, _bufferLength, _blockSize - lengthFieldSize - _bufferLength);

            // Write message length in bits (96-bit little-endian at end of block)
            int lengthPos = _blockSize - lengthFieldSize;
            BinaryPrimitives.WriteUInt64LittleEndian(_buffer.AsSpan(lengthPos), totalBits);
            Array.Clear(_buffer, lengthPos + 8, 4); // Upper 32 bits of 96-bit length

            ProcessBlock(_buffer);

            // Output truncation (Trunc function)
            // Apply final permutation and XOR with state
            Span<byte> finalState = stackalloc byte[_blockSize];
            _state.AsSpan().CopyTo(finalState);
            ApplyPermutationP(finalState);

            for (int i = 0; i < _blockSize; i++)
            {
                finalState[i] ^= _state[i];
            }

            // Take last hashSizeBytes from the state
            finalState.Slice(_blockSize - _hashSizeBytes, _hashSizeBytes).CopyTo(destination);

            bytesWritten = _hashSizeBytes;
            return true;
        }
    }

    /// <inheritdoc/>
    protected override void Dispose(bool disposing)
    {
        if (disposing)
        {
            ClearBuffer(_state);
            ClearBuffer(_buffer);
        }
        base.Dispose(disposing);
    }

    /// <summary>
    /// Processes a single block using the compression function.
    /// </summary>
#if NET5_0_OR_GREATER
    [MethodImpl(MethodImplOptions.AggressiveOptimization)]
#endif
    private void ProcessBlock(ReadOnlySpan<byte> block)
    {
        unchecked
        {
            Span<byte> t1 = stackalloc byte[_blockSize];
            Span<byte> t2 = stackalloc byte[_blockSize];

            // T⊕(h ⊕ m)
            for (int i = 0; i < _blockSize; i++)
            {
                t1[i] = (byte)(_state[i] ^ block[i]);
            }
            ApplyPermutationP(t1);

            // T+(m)
            block.CopyTo(t2);
            ApplyPermutationQ(t2);

            // h = T⊕(h ⊕ m) ⊕ T+(m) ⊕ h
            for (int i = 0; i < _blockSize; i++)
            {
                _state[i] ^= (byte)(t1[i] ^ t2[i]);
            }
        }
    }

    /// <summary>
    /// Applies the T⊕ permutation (uses XOR for AddRoundConstant).
    /// </summary>
#if NET5_0_OR_GREATER
    [MethodImpl(MethodImplOptions.AggressiveOptimization)]
#endif
    private void ApplyPermutationP(Span<byte> state)
    {
        unchecked
        {
            Span<byte> temp = stackalloc byte[_blockSize];

            for (int round = 0; round < _rounds; round++)
            {
                // AddRoundConstant (XOR variant)
                for (int col = 0; col < _columns; col++)
                {
                    state[col * Rows] ^= (byte)((col << 4) ^ round);
                }

                // SubBytes
                ApplySubBytes(state);

                // ShiftBytes
                ApplyShiftBytes(state, temp);

                // MixColumns
                ApplyMixColumns(temp, state);
            }
        }
    }

    /// <summary>
    /// Applies the T+ permutation (uses addition for AddRoundConstant).
    /// </summary>
#if NET5_0_OR_GREATER
    [MethodImpl(MethodImplOptions.AggressiveOptimization)]
#endif
    private void ApplyPermutationQ(Span<byte> state)
    {
        unchecked
        {
            Span<byte> temp = stackalloc byte[_blockSize];

            for (int round = 0; round < _rounds; round++)
            {
                // AddRoundConstant (addition variant)
                for (int col = 0; col < _columns; col++)
                {
                    // Add constant to each column (modular addition on 64-bit column)
                    ulong constant = ((ulong)((_columns - 1 - col) << 4) ^ (ulong)round) << 56;
                    constant |= 0x00F0F0F0F0F0F0F3UL ^ ((ulong)round << 56);

                    int colOffset = col * Rows;
                    ulong colValue = BinaryPrimitives.ReadUInt64LittleEndian(state.Slice(colOffset, 8));
                    colValue += constant;
                    BinaryPrimitives.WriteUInt64LittleEndian(state.Slice(colOffset, 8), colValue);
                }

                // SubBytes
                ApplySubBytes(state);

                // ShiftBytes
                ApplyShiftBytes(state, temp);

                // MixColumns
                ApplyMixColumns(temp, state);
            }
        }
    }

    /// <summary>
    /// Applies the SubBytes transformation using 4 S-boxes.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static void ApplySubBytes(Span<byte> state)
    {
        for (int i = 0; i < state.Length; i++)
        {
            int row = i % Rows;
            state[i] = row switch
            {
                0 or 4 => S0[state[i]],
                1 or 5 => S1[state[i]],
                2 or 6 => S2[state[i]],
                _ => S3[state[i]]
            };
        }
    }

    /// <summary>
    /// Applies the ShiftBytes transformation (circular shift of rows).
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ApplyShiftBytes(ReadOnlySpan<byte> input, Span<byte> output)
    {
        // Shift amounts depend on state size
        ReadOnlySpan<int> shifts = _columns == 8
            ? [0, 1, 2, 3, 4, 5, 6, 7]
            : [0, 1, 2, 3, 4, 5, 6, 11];

        for (int row = 0; row < Rows; row++)
        {
            int shift = shifts[row];
            for (int col = 0; col < _columns; col++)
            {
                int srcCol = (col + shift) % _columns;
                output[col * Rows + row] = input[srcCol * Rows + row];
            }
        }
    }

    /// <summary>
    /// Applies the MixColumns transformation using the MDS matrix.
    /// </summary>
#if NET5_0_OR_GREATER
    [MethodImpl(MethodImplOptions.AggressiveOptimization)]
#endif
    private void ApplyMixColumns(ReadOnlySpan<byte> input, Span<byte> output)
    {
        for (int col = 0; col < _columns; col++)
        {
            int colOffset = col * Rows;
            for (int row = 0; row < Rows; row++)
            {
                byte result = 0;
                for (int k = 0; k < Rows; k++)
                {
                    result ^= GfMul(MdsMatrix[row * Rows + k], input[colOffset + k]);
                }
                output[colOffset + row] = result;
            }
        }
    }

    /// <summary>
    /// Multiplication in GF(2^8) with reduction polynomial x^8 + x^4 + x^3 + x^2 + 1.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static byte GfMul(byte a, byte b)
    {
        unchecked
        {
            byte result = 0;
            byte hi_bit;

            for (int i = 0; i < 8; i++)
            {
                if ((b & 1) != 0)
                    result ^= a;

                hi_bit = (byte)(a & 0x80);
                a <<= 1;
                if (hi_bit != 0)
                    a ^= 0x1d; // Reduction polynomial: x^8 + x^4 + x^3 + x^2 + 1

                b >>= 1;
            }

            return result;
        }
    }
}
